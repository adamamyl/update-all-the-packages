#!/usr/bin/env python3
import subprocess
import re
import os
import hashlib
from datetime import datetime

CONFIG_FILE = "/etc/apt/apt.conf.d/50unattended-upgrades"
LOG_FILE = "/var/log/unattended-upgrades.log"

def log(msg):
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    line = f"{timestamp} {msg}\n"
    with open(LOG_FILE, "a") as f:
        f.write(line)

def get_distro_info():
    distro_id = None
    codename = None
    try:
        distro_id = subprocess.check_output(["lsb_release", "-si"], text=True).strip()
        codename = subprocess.check_output(["lsb_release", "-sc"], text=True).strip()
    except Exception:
        with open("/etc/os-release") as f:
            for line in f:
                if line.startswith("ID="):
                    distro_id = line.split("=")[1].strip().strip('"').capitalize()
                if line.startswith("VERSION_CODENAME="):
                    codename = line.split("=")[1].strip()
    return distro_id or "Ubuntu", codename or "unknown"

def get_repos():
    output = subprocess.check_output(["apt-cache", "policy"], text=True)
    repos = set()
    for line in output.splitlines():
        if "release" in line and "o=" in line and "a=" in line:
            o_match = re.search(r"o=([^,]+)", line)
            a_match = re.search(r"a=([^,]+)", line)
            if o_match and a_match:
                origin = o_match.group(1).strip()
                archive = a_match.group(1).strip()
                repos.add((origin, archive))
    return sorted(repos)

def generate_config(distro_id, codename, repos):
    header = f"""// Automatically generated by update-unattended-upgrades script
// Manual edits will be overwritten on next run.

Unattended-Upgrade::Allowed-Origins {{
"""
    entries = {
        f"{distro_id}:${{distro_codename}}",
        f"{distro_id}:${{distro_codename}}-security",
        f"{distro_id}:${{distro_codename}}-updates",
        f"{distro_id}:${{distro_codename}}-backports",
    }

    for origin, archive in repos:
        if archive == codename:
            archive = "${distro_codename}"
        entries.add(f"{origin}:{archive}")

    body = "".join([f'        "{entry}";\n' for entry in sorted(entries)])

    footer = """};

Unattended-Upgrade::Package-Blacklist {
};

Unattended-Upgrade::Remove-Unused-Dependencies "true";
Unattended-Upgrade::Remove-New-Unused-Dependencies "true";
Unattended-Upgrade::Automatic-Reboot "true";
Unattended-Upgrade::Automatic-Reboot-Time "02:00";
"""
    return header + body + footer, entries

def file_hash(path):
    try:
        with open(path, "rb") as f:
            return hashlib.sha256(f.read()).hexdigest()
    except FileNotFoundError:
        return None

def extract_existing_third_party_entries():
    existing = set()
    if not os.path.exists(CONFIG_FILE):
        return existing
    with open(CONFIG_FILE) as f:
        for line in f:
            line = line.strip().strip('";')
            if line and not any(d in line for d in ["Ubuntu:", "Debian:"]):
                existing.add(line)
    return existing

def main():
    distro_id, codename = get_distro_info()
    repos = get_repos()
    config_content, new_entries = generate_config(distro_id, codename, repos)

    current_hash = file_hash(CONFIG_FILE)
    new_hash = hashlib.sha256(config_content.encode("utf-8")).hexdigest()

    if current_hash != new_hash:
        tmpfile = CONFIG_FILE + ".tmp"
        with open(tmpfile, "w") as f:
            f.write(config_content)
        os.replace(tmpfile, CONFIG_FILE)

        old_third_party = extract_existing_third_party_entries()
        new_third_party = {e for e in new_entries if not e.startswith(f"{distro_id}:")}
        added = new_third_party - old_third_party
        removed = old_third_party - new_third_party

        msg = f"Updated {CONFIG_FILE} with {len(new_third_party)} third-party repos."
        if added:
            msg += f" Added: {', '.join(sorted(added))}."
        if removed:
            msg += f" Removed: {', '.join(sorted(removed))}."
        log(msg)

if __name__ == "__main__":
    main()
